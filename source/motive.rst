动机
====

在量子化学领域中，计算方法的开发瓶颈除了最初的灵感与公式推导之外，表达式的程序实现与其正确性也非常重要。事实上，往往后者左右了方法的开发效率、完成度，以及方法的推广流传程度。通常，应用一个量子化学方法或者会在已有程序上作改动，或者自己重新构建一个程序。

对于程序改动，方法开发者通常需要面临理解复杂程序结构、阅读大量冗余代码、了解编译流程、缺少充足的文档等困难，在程序上所消耗的时间不亚于、甚至远高于方法开发的耗时。成功的程序改动决定于方法开发者的程序调试能力。

而对于从头构建程序，耗时将会因人而异，这取决于方法开发者的综合程序能力，包括编译、调试、框架搭建、底层工具设计、公式的程序表达等等。同时，由于大多数方法开发者只关心实现而不关心代码质量，因此这类程序的复用性较差，通常不会有充足的文档，也不适合进行稍复杂的改动。在量子化学发展的早期，正因为程序的开发难以跟上量化方法的发展，同时课题组的交流与合作受限于没有因特网，从而催生了数量众多的量化软件或程序。

这份文档更为偏向于从头构建程序。早期的计算机发展主要受限于计算效率与内存，而即使是很小的量子化学的任务，也对这两者有较高的消耗。然而，现在的微机已经可以快速处理中小体系的量子化学计算；从方法开发的角度上看，硬件不应当成为瓶颈——方法的开发只需要较小的模型体系通常即可。而对硬件要求的降低，催生了高级语言的流行。对于 Python，它对方法开发者的限制会显著减小：不存在编译问题，调试可以通过实时交互界面 (interactive interface，例如 Python consoles 或 Jupyter Notebook) 或 IDE 完成。对于底层工具，Python 社区提供众多的库函数可以胜任；在量子化学领域，底层工具绝大部分与矩阵计算有关，因此 NumPy 可以胜任。

对于量子化学中的 Post-HF 与 DFT 领域，剩下的问题则是获得量子化学积分、量子化学相关的底层工具、程序框架设计与复用性、以及公式与程序的对应。对于前两者，现有的软件，例如 `Psi4 <https://github.com/psi4/psi4>`_ 与 `PySCF <https://github.com/sunqm/pyscf>`_ 均提供了不少对象接口 (API)，对它们的活用将会简化程序书写上的困难。对于第三个问题，我们暂且不考虑。

因此，也许看起来从头构建程序是很可怕的事情，但在现在众多程序便利的环境下，方法开发者所真正面临的问题已经可以回归到最为本质的问题，即如何将公式写成程序。在这份教程中，一个目标便是对于我们需要计算的公式中的大多数项 (譬如张量乘积)，尽可能在 1 行代码内解释，至少一般可以在 5 行以内的代码块内说明。并且，我们不希望涉及非必要的算法细节；整个教程中，绝大多数代码开始将不会多于 3 个 Tab，尽少使用循环与判断，让程序的书写的目的回归于公式表达本身。

写这份教程的灵感实际上来源于 Psi4 的一份官方简易实现 `Psi4NumPy <https://github.com/psi4/psi4numpy>`_；它包含了许多高级 Post-HF 方法简单但有效的实现。但 Psi4 并非是原生的 Python 程序，它基于 C++ 开发，因此在调用 Psi4 程序时多少会有一些困难，也会出现在错误调用 C++ 程序后 Python 内核崩溃，无法继续交互地使用 Jupyter 笔记本的问题。因此，这份教程更倾向于使用几乎原生的 Python 软件 PySCF 辅助我们进行中间步骤的量化计算。
